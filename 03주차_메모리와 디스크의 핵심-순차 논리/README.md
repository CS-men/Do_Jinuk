# < 3주차 - 메모리와 디스크의 핵심: 순차논리 >

| 135~163p | 작성자 : `김영훈`,`도진욱`,`이주영` / 학습 기간 : *2022.02.24. ~ 2022.03.09.* |
| -------- | -----------------------------------------------------------: |


---

<br>

#### - '컴퓨터는 비트를 어떻게 기억하는가'

> 조합 논리는 '흐름을 따른다'. 즉, 조합 논리는 입력에 의해서만 출력이 결정된다. 하지만 조합 논리만 사용해 컴퓨터를 만들 수는 없다. 조합 논리만으로는 흐름의 일부분을 떼어내서 기억해둘 수 없기 때문이다. 예를 들어, 현재 처리 중인 수가 어떤 수인지 기억할 수 없다면 1부터 100까지 모든 정수의 합계를 구하는 것은 불가능하다.
>
> -135p, 순차논리를 알아야 하는 이유.

- **순차 논리(Sequential logic)** : 순서는 '시간적으로 어떤 값 뒤에 오는 다른 값'이라는 뜻인데, 순서를 구현하기 위해서는 당연하게도 시간을 디지털 회로에서 만들어내야만 한다. 그렇게 순차 논리는 입력의 현재 상태와 과거 상태를 함께 고려한다.

---

### 1) 시간 표현과 상태 기억

<br>

- **발진자(Oscillator)** : 인버터의 출력을 입력에 연결하는 방식. 즉, 피드백의 연결을 통해 출력이 0과 1을 진동하게끔 구현할 수 있다. 
  - 시간을 측정할 수는 있지만 전파 지연에 따라 진동속도가 결정되며, 온도에 따라 달라지기도 한다. 즉, 불안정적으로 진동하는 방식이다.
  - (크리스털을 활용하면 정확한 발진자를 적은 비용으로 만들 수 있다고는 하는데.. ~~이렇게 깊게는 몰라도 될 것 같다..^^~~)

<br>

- **클록(Clock)** : 발진자는 컴퓨터에 클록을 제공하는데, 클록이란 '시간을 셀 수 있게 해주는 신호'를 뜻한다. 즉, 시간을 표현할 수 있게 한다.

  - 오버클로킹(overclocking) : 통계적으로 빈의 중간 정도에 위치하는 부품을, 부품이 고장 나지 않을 범위 안에서 클록을 빠르게 공급하는 도박을 한다는 뜻.

  > 현재의 모든 컴퓨터는 동기 논리를 사용합니다. 입력 세트는 다양한 논리 회로로 설정됩니다. 신호가 다양한 논리 단계를 통과하는 데 시간이 걸리지만 일정 시간이 지나면 안정됩니다. 이러한 출력은 레지스터에 저장되고 다음 라운드의 입력이 됩니다. 따라서 컴퓨터는 입력이 출력을 생성하고 다음 사이클의 입력이 되기 위해 출력을 캡처하는 시간을 측정하는 구형파 신호가 필요합니다. 이 신호는 *Clock*입니다. 컴퓨터 코어의 모든 섹션에 공급됩니다. *Clock* 주기는 "틱" 사이의 시간이며 코어 내의 각 하위 시스템은 최악의 경우에도 *Clock* 주기보다 짧은 시간 안에 모든 작업을 완료할 수 있어야 합니다.
  >
  > (- Quora 에서의 관련 질문 중 'Alec Cawley'의 답변 참고.)

<br>

- **래치(Latch)** : 1비트의 정보를 기억할 방법을 뜻한다.

  - OR 게이트 래치

    - 이전의 입력을 기억할 수 있는 아주 간단한 래치이다.
    - 다만, out을 다시 되돌릴 방법은 없다는 단점이 있다.

  - AND-OR 게이트 래치

    - out을 reset신호의 조절로 변환이 가능하다는 장점으로 OR게이트의 단점을 보완하였다.

  - S-R 래치

    - AND-OR 게이트 래치보다 좀 더 읽기 쉽게? 1비트 메모리를 만들어 낼 수 있게 한다.
    - 설계가 대칭적이며, 회로가 대칭이기 때문에 set과 reset 신호의 지연 시간이 거의 비슷하다.
    - (NAND게이트보다 NOR게이트가 더 전력을 많이 사용하고, 더 복잡하다는 것을 알 수 있었다.)

    > S-R 래치에서 입력이 왜 set바, reset바 인지 이해가 되지 않았는데 논리표를 분석하고 이해할 수 있었다!
    >
    > set의 값이 곧 Q가 되고, reset의 값이 곧 Q바 가 된다. 그리고, Q의 반대값이 Q바 가 가질 수 있게 되니 정말 생각을 많이 하고 설계하지 않았나 느낄 수 있었다.

<br>

- **게이트가 있는 래치**
  - 정보를 기억할 방법이 있으므로, 어느 시점에 무언가를 기억한다는 것이 어떤 뜻인지 알 수 있었다.
  - S-R 래치의 입력에 게이트를 한 쌍 추가한 회로
    - gate bar의 입력이 거짓(하이)인 경우 set bar와 reset bar의 입력 값이 어떤 값이든 아무 관계가 없게 된다.
    - S와 R 게이트의 입력이 모두 1이기 때문에 출력이 그대로 유지된다.
    - (이때부터 논리 게이트를 하나 하나 따져가면서 작동원리를 이해하고 결과표가 왜 이렇게 나오게 되는지 따져나가기엔 너무 힘들었다. 그래서 이때부터 각 래치의 목적만 파악하려고 하였다.)
  - 게이트가 있는 **D래치**
    - 문제점 : gate bar가 참(로우)인 상태에서는 D의 변화가 그대로 출력에 나타나게 된다.
    - 개선해야 할 점 : 게이트를 여는 시간을 최소화해서 거의 순간적으로 D의 상태에 맞춰 출력 상태를 변경할 수 있게 해야 한다.

<br>

- **플립플롭(flip-flop)** : 에지(edge)에 의해 데이터 변화가 촉발되는 래치 (= edge-triggered latch)
  - 에지(edge) : 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아내는 것.
  - D 플립플롭 : positive edge-triggered 플립플롭을 뜻하며, 클록의 논리 값이 0에서 1로 바뀌는 순간에 작동하여 플립플롭의 출력이 바뀐다.
    - 클록 에지 근처의 설정과 유지 시간을 제외한 나머지 시간에는 D의 값이 무엇이든 출력에 영향이 없음을 알 수 있다.

<br>

- **카운터** : 플립플롭을 응용한 회로 중 하나로, 1, 2, 3 순서대로 수를 센다.
  - 3비트 리플 카운터(3bit ripple counter)
    - 결과가 왼쪽에서 오른쪽으로 퍼져나가는 것 처럼 보인다.
    - 각 비트의 상태가 다른 비트의 상태 변화에 약간의 시차를 두고 바뀌기 때문에 이 회로를 비동기 카운터(asynchronous counter)라고도 부른다.

<br>

- **레지스터** : 클록을 공유하는 여러 D 플립플롭을 한 패키지에 넣은 것을 뜻한다.

<br>

---

### 2) 메모리 조직과 주소 지정

- **임의 접근 메모리**
- **읽기 전용 메모리**

<br>

---

### 3) 블록 장치

- 

<br>

---

### 4) 플래시 메모리와 SSD

- 

<br>

---

### 5) 오류 감지와 정정

- 

<br>

---

### 6) 하드웨어와 소프트웨어 비교



- 

<br>

---

## 📋 이번 학습으로 인해 느낀 점 : 

-   139페이지에서 게이트를 이용하여 래치를 구성하는 것을 보고 많이 신기했다. 솔직하게는 개인적으로 한 논리게이트에 대한 이해까지만 재밌었지, 그 이상은 너무 복잡하다고만 생각했었는데, 목적에 맞게 설계된 논리게이트 회로를 보고나서야 새로운 것을 깨닫게 된 것 같다. 마치 알고리즘을 코드로 구현하여 문제를 풀 듯이, 문제를 해결하기 위해 창의적으로 게이트를 만들라고 하였을 때의 알맞은 해답을 보는 것 같았다.
-   회로에 대한 이해가 많이 어려웠던 것도 맞지만, 하드웨어에 대한 설명을 글로 배운다는 것이 매우 힘들기도 하였다. 물론, 이해를 돕기 위해 적절한 그림이 삽입되어 있긴 해서.. 결국 내 문제점이라고 생각하려 한다.
-   모든 것을 이해하고 기억하려 했던 건 큰 도전이었던 것 같다. 좀 더 마음을 비우고 조바심 갖지 않고 천천히 능력껏 알아가보려 한다. 대략 한달전부터 나는 마치 친구를 만나자마자 여러가지 질문을 한 것만 같은 기분이었다. 이제는 조금 더 시간을 가지고 알아가 봐야 겠다.