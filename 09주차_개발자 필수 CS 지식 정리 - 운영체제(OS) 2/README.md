# < 9주차 - 개발자 필수 CS 지식 정리 - 운영체제(OS) II >

| - 220427 작성완료 | 작성자 : `도진욱` / 학습 기간 : *2022.04.21. ~ 2022.04.27.* |
| ----------------- | ----------------------------------------------------------: |


---

<br>

 지난 학습 기간 동안 운영체제에 대해 공부하며 정리해보았었다. 그러던 중에 운영체제가 너무 중요함에도 그렇게 한 주로 마무리하기가 너무 아쉬웠다. 그렇게 이번 한 주를 운영체제에 대해 더 공부해보기로 하였고, 당연하게도 운영체제로 한 학기를 공부하기도 하는 만큼 더 고민하여 다음 주에도 공부를 해볼 지, 다른 것에 대해 공부할 지 생각해 보려고 한다. 저번 주에 기초적인 내용에 대해 학습하였다면 이번 주는 약간 진도를 더 나아감과 동시에 심화적인 내용까지도 접해보려고 한다. 그리고 그렇게 공부해 보았던 것에 대해 면접 관련 질문들이 있다면 조사해서 작성해 보려고 한다.

 저번 시간에 '운영체제, 프로세스, 스레드, 데드락, 프로세스 스케줄링'에 대해 알아보았는데, 이번 주는 운영체제 파트에서 메모리 파트와 관련된, 약간은 심화된 주제로 알아보았다. (참고한 출처는 각 질문에 대한 답변 혹은 파일의 하단에 모두 링크를 걸어두었습니다.)

---

<br>

## 메모리의 각 영역에 대해 말해주세요.

- 이전에도 메모리의 구조에 대해 배웠는데, 이번 한 주 메모리에 대해 공부하면서 다시 한 번 공부해 보기로 하였다.
- 공룡책에서, 메모리는 현대 컴퓨터 시스템의 핵심이라고 말하고 있으며 그렇기에 메모리에 대해 알 필요가 충분히 있음과 동시에, 면접 상황에서도 많이 물어보는 질문 중 하나가 메모리 관련 질문이라고 한다.
- 프로그램이 실행되기 위해 메모리에 프로그램을 불러와야 하는데, **운영체제에서 프로그램의 실행을 위해 메모리 공간을 제공하게 된다.** *(그렇기 때문에 메모리를 알아야만 한다!)*
- 아래 그림과 같이 메모리에는 4가지 영역이 있다.

![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcqk9Wt%2Fbtq9Rehkwfd%2F6QNk4WEKb7O7JR4TvXakvK%2Fimg.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcqk9Wt%2Fbtq9Rehkwfd%2F6QNk4WEKb7O7JR4TvXakvK%2Fimg.png)

> 위 그림으로 메모리에 대해 말할 수 있는데,
>
> 1. code 영역 : text 영역이라고도 하며, 프로그램의 코드가 저장되는 영역이다. CPU에서 수행할 수 있는 기계어 형태로 변환되어 저장되고, CPU는 코드영역에 저장된 명령어를 하나씩 가져가서 처리한다.
> 2. data 영역 : 전역변수, 정적변수 등 프로그램이 사용하는 데이터를 저장하는 공간이다. 프로그램의 시작과 함께 할당되고, 프로그램이 종료되면 소멸된다.
> 3. heap 영역 : 프로그래머가 직접 관리할 수 있는 메모리 영역이다. 메모리 공간이 동적으로 할당되고 해제될 수 있다.
> 4. stack 영역 : 함수의 호출과 관계되는 지역변수와 매개변수가 저장되는 영역이다. 함수의 호출과 함께 할당되고, 함수의 호출이 종료되면 해제된다. 또한 LIFO 방법을 따르며, 컴파일 시 stack 영역의 크기가 결정되므로 무한정 할당할 수 없다. 이 크기를 초과할 시 stack overflow가 발생하게 되는 것이다.

*(출처 :*

*https://velog.io/@limhizy15/OS-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A0%A8-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8*

*https://zangzangs.tistory.com/107*

*https://hyonee.tistory.com/95 )*

<br>

## 물리적 주소와 논리적 주소의 차이를 설명하시오.

- 위에서 메모리를 배웠으므로 이제 주소에 대해서도 다룰 수 있는데, 이에 대해서는 너무 깊게 전공 지식을 다루어야만 하므로 '공룡책(인프런 강의)'의 힘을 빌려 학습하였다.
- 지난 주에 프로세스 스케줄링에 대해 공부하면서, OS는 PCB(Procss Control Block, 프로세스 제어 블록)을 유지 관리 한다고 했는데, 그에 대한 이유로는 운영체제가 프로세스에 대한 중요한 정보를 저장하며 각 프로세스의 상태 변경에 따라 PCB를 전달시킨다고 배웠었다.
- 이 때에 레지스터(CPU 내부의 일시적인 기억 장치) 정보를 PCB에 담게 되고, 레지스터는 base와 limit으로 나눌 수 있는데, base(기준 레지스터)는 프로세스가 메모리에서 사용할 수 있는 가장 작은 물리적 주소(physical address)를 의미하고, limit은 사용할 수 있는 주소의 범위를 말한다.
  - (ex. base: 300040, limit: 120900 일 때, 프로세스가 접근할 수 있는 메모리 주소의 범위는 300040~420940(= 300040+120900)이 된다.)

> 물리적 주소란 위와 같이 메모리의 물리적 위치를 식별할 수 있는 주소를 말한다. 이는 실제로 메모리에 실제  존재하는 위치를 뜻한다.
>
> 논리적 주소란, 프로세스가 생성될 때에 주소 공간(Address space)이 만들어지게 되고 그때 사용되는 것이 논리적 주소이다. CPU는 이 주소를 활용하게 된다. 실제 주소가 아니므로 '가상 주소'라고도 한다.
>
> 또한, 논리적 주소는 프로그램이 메모리에 적재될 때 생기는 독자적인 주소 공간이라고 할 수 있다.
>
> ~~(난 여기서 의문이 들었다. 그럼 물리적 주소만 알면 되지 않을까? 논리적 주소란 대체 왜 존재하는 걸까? 이 해답은 많이 찾아본 결과, MMU가 대답해 줄 수 있었다.)~~

*(출처 :*

*https://ohcode.tistory.com/2*

*https://kosaf04pyh.tistory.com/245*

*https://en.wikipedia.org/wiki/Logical_address*

*https://quizlet.com/558420088/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC-flash-cards/*

*https://velog.io/@adam2/OS%EA%B8%B0%EC%B4%88%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC%EC%A3%BC%EC%86%8C-%EB%B0%94%EC%9D%B8%EB%94%A9* )*

<br>

## MMU가 무엇인가요?

- 보통 이런식으로 질문하진 않을 것이다. 다만, MMU를 모르고서 주소 이야기를 할 순 없기 때문에 따로 담아보았다.
- MMU란 위에서 적은 내 궁금증에 대한 해결책이었는데, 일단 정의부터 말하자면 다음과 같다.

> MMU(Memory Management Unit, 메모리 관리 장치)
>
> ![https://velog.velcdn.com/post-images%2Fadam2%2F53b752a0-327f-11ea-89c2-a9689e76c48b%2Fimage.png](https://velog.velcdn.com/post-images%2Fadam2%2F53b752a0-327f-11ea-89c2-a9689e76c48b%2Fimage.png)
>
> : CPU에서는 각 프로세서마다 독립적인 논리적 주소를 할당하는데, 위와 같이 MMU를 통해 실제로 접근해야하는 메모리의 주소인 물리적 주소를 얻을 수 있게 되는 것이다.
>
> 즉, MMU는 CPU가 메모리에 접근하는 것을 관리하는 하드웨어라고 할 수 있다.
>
> 위의 예시처럼 논리적 주소가 245라면 재배치 레지스터에 저장되어 있는 주소값을 더해 8245라는 실제 메모리 주소인 물리적 주소에 접근할 수 있게 된다.
>
> 
>
> ![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FAtDJH%2FbtqFhlwDdKf%2FyywESSEyHOMLMWyzOPcBqk%2Fimg.jpg](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FAtDJH%2FbtqFhlwDdKf%2FyywESSEyHOMLMWyzOPcBqk%2Fimg.jpg)
>
> : 위와 같이 논리적 주소를 물리적 주소로 변환시켜줄 수 있다.
>
> 또한, 실제로 다수의 프로세스 혹은 물리적 메모리의 용량을 초과하는 대량의 프로세스를 동시에 동작시킬 수가 있는데, 이를 파고들면 다음과 같이 해석할 수 있다.
>
> 여러 개의 프로그램을 보조기억장치에서 프로세스(메모리로 올라오는)상태로 전이시킬 때에, 일부의 코드만 불러와서 그 일부들의 논리적 주소만, 메모리의 물리적 주소에 할당시켜서 사용할 수 있게 되는 것이다. 그렇게 하여 프로그램의 일부만 메모리로 올라가도록 하는 것으로 볼 수 있고, 실제로 메모리로 올라가는 크기의 총합은 결코 메모리를 초과하지 않게 된다.

- 즉, 위에서의 궁금증이었던, 논리적 주소의 존재 이유에 대해 MMU가 답해줄 수 있게 되었다.
  - MMU가 지원되지 않으면, physical address를 직접 접근해야 하기 때문에 부담이 있다.
  - MMU는 사용자가 기억장소를 일일이 할당해야 하는 불편을 없애준다.
  - 가상 프로세스의 크기가 실제 메모리의 용량을 초과해도 실행될 수 있게 해준다.

*(출처 :*

https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=leojesus&logNo=80013927980

*https://velog.io/@adam2/OS%EA%B8%B0%EC%B4%88%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC%EC%A3%BC%EC%86%8C-%EB%B0%94%EC%9D%B8%EB%94%A9*

*https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EA%B4%80%EB%A6%AC_%EC%9E%A5%EC%B9%98*

*https://cyber0946.tistory.com/51 )*

<br>

## 주소 바인딩이 무엇인가?

- 위에서 **논리적 주소를 물리적 주소로 연결시키는 작업**을 주소 바인딩이라고 한다. 또한, 위의 MMU는 실행 시간 바인딩의 재료인 것이다.

  ~~(사실, 주소 바인딩의 종류를 알고 각각의 특징을 외운다기 보다는, 주소 바인딩이 무엇인지 인지하고, 실행 시간 바인딩이 왜 사용되는 지 알아야 하며, 실행 시간 바인딩을 위해 MMU가 쓰이고, MMU의 동작 방식을 아는 것이 낫다고 판단된다.)~~

- 주소 바인딩의 종류

  > 1. 컴파일 타임 바인딩(Compile time binding)
  >    - 물리적 메모리 주소가 프로그램을 컴파일할 때 결정되는 주소 바인딩 방식으로, 프로그램 내부에서 사용하는 주소와 물리적 메모리 주소를 동일하게 하는 방식이다.
  >    - 위에서 배웠던 것처럼, 메모리의 용량을 초과하는 프로세스들을 다룰 수가 없으므로, 하나의 프로세스만 사용하는 것이 확실할 때만 사용할 수 있는 방식이다.
  >    - 그러므로, 사용하지 않는다.
  > 2. 로드 타임 바인딩(Load timd binding)
  >    - 프로그램의 실행이 시작될 때 물리적 메모리의 주소가 결정되는 주소 바인딩 방식
  >    - 물리적 메모리 주소와 논리적 메모리 주소를 분리시켜서 프로그래밍 한다.
  >    - 메모리를 참조하는 명령어를 모두 변경해야 하므로 메모리 로딩 시간은 길어지게 된다. 그러므로 사용하지 않는다.
  > 3. **실행 시간 바인딩(Execution time binding)**
  >    - 프로그램이 실행을 시작한 이후에도 프로그램이 위치한 물리적 메모리 상의 주소가 변경될 수 있는 바인딩 방식
  >    - CPU가 주소를 참조할 때마다 해당 데이터의 물리적 메모리의 위치를 찾기 위해 주소 매핑 테이블(address mapping table)을 이용해 바인딩을 점검한다.
  >    - 기준 레지스터와 한계 레지스터를 포함한 MMU가 뒷받침 되어야 한다.
  >
  > - *이렇게 보면 실행 시간 바인딩 보다 로드 타임 바인딩이 더 효율적이라고 생각되어 지지만, **하드웨어 성능이 높아진 덕분에**, 실행 시간 바인딩을 사용하는데 무리 없이 사용이 가능하게 되었고, 로드 타임 바인딩은 위의 특성 탓에 사용하지 않는 방식이 되었다.*

*(출처 :*

*https://lifelife7777.tistory.com/178*

*https://8iggy.tistory.com/179?category=1023741)*

---

<br>

마지막으로, 주제와 관련하여 참고하면 좋은 곳 링크입니다.

1. 동영상 강의 - 공룡책(인프런) (https://www.inflearn.com)
2. 글 - 어느 개발자의 지식 정리 tistory 링크 (https://8iggy.tistory.com/)
1. 정리글 - 공룡책으로 정리하는 운영체제 (https://parksb.github.io/articles.html)